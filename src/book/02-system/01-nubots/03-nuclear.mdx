---
section: System
chapter: NUbots
title: NUClear
description: Introduction to NUClear and how it is used in the NUbots codebase.
slug: /system/nubots/nuclear
---

NUClear is the software framework used in the main NUbots codebase. It is a message passing system designed to be modular and fast. The [NUClear readthedocs page](https://nuclear.readthedocs.io/en/latest/) contains a detailed description of NUClear, which this page is based off. The [NUClear Roles repository](https://github.com/Fastcode/NUClearRoles) contains a detailed description of the NUClear roles system, much of which the [roles section](/system/nubots/nuclear/#nuclear-roles) in this page is based off.

# Components

## PowerPlant

![A collection of Reactors around the PowerPlant in the center. Double ended arrows point to and from the PowerPlant to each Reactor.](images/power_plant.svg 'PowerPlant with Reactors. Image: https://nuclear.readthedocs.io/en/latest/components.html')

The PowerPlant is the central message system through which reactors communicate. It takes ownership of any data emitted by reactors into the system and executes the required reactions. NUClear is [multi-threaded](<https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)>). The PowerPlant handles all threading logic.

## Reactors

A reactor can be thought of as a module. All modules in the NUClear system are an extension of `NUClear::Reactor`. Reactors define reactions and the conditions under which they will process. They may also emit data to the PowerPlant.

## Reactions and Tasks

Reactions run tasks when the required data is available and/or when certain conditions are true. A task is the current execution of a defined reaction within the system. These functions are bound by NUClear as callbacks, and it is the execution of these callbacks which will assign tasks to a thread.

Reactions are created by subscribing to the PowerPlant through [DSL On Statements](/system/nubots/nuclear/#on-statements).

# NUClear DSL

## On Statements

Reactors make subscriptions to the PowerPlant using on statements, which define the conditions for reactions to run.

An on statement has the following form

```cpp
on<...>(...).then(...);
```

This can be split into three parts. The first is the `on<...>` which is the DSL request. The `(...)` contains any runtime arguments. `.then(...);` is the callback, which is what will be executed when the reaction is triggered.

### DSL Request

The DSL request can be fused together through any combination of DSL words. The combination of these words will define the kind of reaction which is being requested. For example, Trigger will define a reaction that should occur when a required data type is emitted, while Every will define periodic reactions.

For reactions to occur, at least one Binding DSL word should be present in the DSL Request. From the provided DSL words, those which are binding are: Trigger, With, Every, Always, Startup, Shutdown, TCP, UDP and Network.

| DSL Word | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Trigger  | Is used to request data dependent reactions. `on<Trigger<T>>()` will execute the task whenever T is emitted into the system. Read only access to T is given via a callback. `on<Trigger<T1, T2, ... >>()` requires multiple types and will only trigger when all the trigger types have been emitted at least once since the last occurence of the event.                                                                                                  |
| With     | This is used to define any extra data which should be provided to a subscribing a reaction. This shoud be fused with at least one other DSL word as the use of this word alone will not trigger a reaction within the system. `on<Trigger<T1>, With<T2>>()` will trigger when T1 is emitted into the system. It will give read-only access of T1 and T2 to the callback. If T2 is not present when T1 is emitted to the system, the reaction will not run. |
| Last     | This instructs the powerplant to store the last n messages (of the associated type) to the cache and provide read-only access to the subscribing reaction. `on<Last<n, Trigger<T, ...>>>()` will store the next $n$ messages of each of the Trigger types in a list with the oldest element first. When the reaction is triggered again, the oldest copy will be dropped and the newest copy appended to the list.                                         |
| Optional | This is used to signify any optional properties in the DSL request. `on<Trigger<T1>, Optional<With<T2>()` will run when T1 is emitted into the system. If T2 is available, then the reaction will be given read-only access to the most recent emission of T2.                                                                                                                                                                                             |
| Single   | This is used to specify that only one instance of the associated reaction can execute during runtime. `on<Trigger<T, ...>, Single>()` will only allow one task for this reaction to be executed or in the queue at any given time. This should be fused with another DSL word, such as `Trigger` in the example.                                                                                                                                           |
| Buffer   | This is used to specify that up to n instances of the associated reaction can execute during runtime. `on<Trigger<T, ...>, Buffer<n>>>()` will create and schedule a new task if there are less than $n$ existing tasks for this reaction. This should be fused with another DSL word, such as `Trigger` in the example.                                                                                                                                   |
| Priority | This word assigns a priority to any tasks created to determine scheduling order in the PowerPlant. `on<Trigger<T, ...>, Priority::HIGH>()` will schedule the task with HIGH priority when the reaction is triggered. Available priority settings are REALTIME, HIGH, NORMAL, LOW, IDLE. This should be fused with another DSL word, such as `Trigger` in the example.                                                                                      |
| Sync     | This option sets the synchronisation for a group of tasks. `on<Trigger<T, ...>, Sync<Group>>()` will allow only one task from the `Group` to execute at any given time. This is similar to the `Single` word, but applying to multiple reactions. This word helps prevent race conditions. This should be fused with another DSL word, such as `Trigger` in the example.                                                                                   |
| Every    | This is used to request any periodic reactions in the system. `on<Every<2, std::chrono::seconds>()` will create a task every two seconds. `on<Every<2, Per<std::chrono::seconds>>()` will create a task two times per second.                                                                                                                                                                                                                              |
| Always   | This is used to request any continuous reactions in the system. `on<Always>` will ensure a single instance of the associated reaction is running at all times.                                                                                                                                                                                                                                                                                             |
| Startup  | This is used to specify reactions which should occur at startup. `on<Startup>()` will create a task after all reactors have been installed into the PowerPlant but before the system starts the main execution phase.                                                                                                                                                                                                                                      |
| Shutdown | This is used to specify any reactions/tasks which should occur during shutdown. `on<Shutdown>()` will create a task after the shutdown command has been emitted and all existing tasks have been completed.                                                                                                                                                                                                                                                |
| IO       | This is used to trigger reactions based on standard I/O operations using file descriptors. `on<IO>(file_descriptor)` will create a task when the communication line matches the descriptor.                                                                                                                                                                                                                                                                |
| Network  | NUClear provides a networking protocol to send messages to other devices on the network. `on<Network<T>>()` will create a task when T is emitted using the emission type `Scope::NETWORK`.                                                                                                                                                                                                                                                                 |

More information on DSL words for on statements can be found at the [NUClear readthedocs page](https://nuclear.readthedocs.io/en/latest/dsl.html#on-statements).

## Emit Statements

Emit statements are used by Reactors wanting to emit data to the PowerPlant. When using NUClear, data will most likely be emitted during a reaction. However, where necessary, emissions can also occur during reactor construction, or in some cases from within the PowerPlant itself.

Any data emitted to the PowerPlant will be sent with a unique pointer. The PowerPlant will take ownership of this pointer and run any necessary callbacks to trigger reactions.

Data can be emitted under varying scopes. These can be local or network emissions. More can be found on emit statements on the [NUClear readthedocs page](https://nuclear.readthedocs.io/en/latest/dsl.html#emit-statements).

### Local Emitting

These emissions send data to the local instance of the NUClear powerplant. There are a number of scopes under which these emissions can take place. The syntax for these emissions are `emit<Scope::SCOPE>(data, dataType);`, where `SCOPE` is replaced with a scope as defined below.

| Scope | Description |
| LOCAL | When emitting data under this scope, tasks are distributed via the thread pool for execution. This is the default behaviour when emitting. |
| DIRECT | When emitting data under this scope, the tasks created as a result of this emission will bypass the threadpool, and be executed immediately. |
| INITIALISE | This scope emits data as the system starts up. |
| DELAY | This will emit data, after the provided delay. The syntax includes a delay time `emit<Scope::DELAY>(data, delay(ticks), dataType);`. |

### Network Emitting

# NUClear Roles

The NUClear roles system is a build and messaging system for the NUClear framework. It uses [CMake](https://cmake.org/) and [Python](https://www.python.org/) to manage the construction of various executables made up of a selection of modules. These executables are called roles.

CMake is used as the main system for generating the libraries and executables that are used for the final binary. Note that it utilises [globbing](<https://en.wikipedia.org/wiki/Glob_(programming)>) to find the sources that are used for modules. If you add or remove a file, you must rerun cmake so that it locates the new files.

# Managing Reactions

<!-- Definitions section to go in glossary? -->
