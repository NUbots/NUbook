---
section: System
chapter: Foundations
title: Director
description: Introduction to the Director and how to use it to build behaviours.
slug: /system/foundations/director
---

The Director is a framework and algorithm used to control the flow of behaviour on the robots.
It allows composable behaviours that can take advantage of transition rules to ensure that the robot performs the right task at the right time.

The Director does this by providing a set of new DSL keywords to NUClear that describe what tasks to run, what conditions are required, and how those tasks build on other tasks.
It then uses these keywords to make a graph that it will use to decide which tasks to execute in order to achive the goals of the modules.

The two DSL components that are added are Providers and Tasks.

## Providers

Providers are implemented as NUClear reactions and live in a NUClear `on` statement.
They are the components which "provide" the functionality needed to perform a task, either by doing it directly or by running a series of subtasks.
They form the basis of the modules that implement behaviours.
Each provider will provide for a specific message type in a specific situation.
For example a provider which executed a walk task, the code might look like:

```cpp
on<Provide<Walk>>().then(...);
```

Providers are triggered whenever a Task needs to be executed by the Director, however they can also be triggered using other NUClear keywords.
The Director will ensure that any Provider which is not currently active will not run if it is not active, even if the other triggers would make it run.
For example if the walk engine module wants to update at 10Hz when it is running a Provider may look like.

```
on<Provide<Walk>, Every<10, Per<std::chrono::seconds>>().then(...);
```

This Provider would then run once every time the Walk Task/message was updated, as well as running at 10Hz while the Provider is active.

It is possible to run an inactive Provider with the `Optional` keyword.

```
on<Optional<Provide<Walk>>, Trigger<Sensors>>().then(...);
```

The reaction will run regardless of if there is a Walk task if a Sensors message is emitted. The Walk Task will be empty, and the Provider cannot emit subtasks.

Subtasks must be emitted from the Provider reaction to be considered a child of that Provider. If the Task is emitted from a non-Provider reaction, it will be considered a root task.

### Provider Groups

When there are multiple Providers which provide for a single Task type they are considered a provider group. For example, a both a static walk module and a ZMP walk module could have `Provide<Walk>` reactions. These two Providers would be considered a Provider group for the Walk task.

When a Provider group is running, only one of the Providers in that group is allowed to execute at a time.

When a new Task is emitted the Director will determine which of the Providers in a group to run based on the current state of the system as well as any extra DSL keywords that are on the Provider's decleration. If both Providers could run, then the one declared first will run.

If the state of the Director system changes such that the currently active Provider can no longer run, then the Director will attempt to reassign that task to another Provider in the group.

Provider groups operate together as a single unit. Any Task that is emitted from a Provider in a group is considered as being emitted from that group. Considering the walk examples, both Providers may emit a `LegIK` Task. Regardless of which Provider is active, the `LegIK` Task will be considered as coming from the walk Provider group. If the walk Providers emit different subtasks, then the old subtasks will be considered "finished" and removed from the graph, and the new subtasks will start running.

### Provider Types

There are three different Provider types that can be used.
These three provider types along with the `When` and `Causing` DSL words determine the flow of a Provider, executing code as the Director changes which Tasks it executes.

#### Start

A Start Provider is used to set up the state of a Provider when it starts running. Start is executed when a Provider group has no active Tasks and then is given to one, ie it gains control.

For example, the walk may need a Start Provider to initialise the state of the walk engine before it starts running.

```cpp
on<Start<Walk>>().then( { // this is a Start Provider type for the Walk Task
    // Initialise walk
    delta = NUClear::clock::now();
    walk_engine.reset();
    current_orders = Eigen::Vector3d::Zero();
});
```

#### Provide

Provide is the normal Provider which executes the functionality for a Task, as described previously. It will run after Start, if a Start exists.

```cpp
on<Provide<Walk>>().then( { // a Provide Provider type for the Walk Task
    // Run the walk
    auto goals = calculate_joint_goals();
    emit<Task>(std::make_unique<LegIK>(goals));
});
```

#### Stop

Stop Providers run when a Provider group is losing control and will no longer run. That is, when the Provider group has no active Task. This is useful for performing a cleanup of the Provider.

A Stop Provider cannot run unless either a Start or Provide has run for that Provider group.

Example:

```cpp
on<Stop<Walk>>().then({ // a Stop Provider type for the Walk Task
    // Log that the walk has stopped
    log<NUClear::TRACE>("Walk Stopped");
});
```

### When

A When condition is used to ensure that a Provider will only execute when its conditions are met.
These conditions are provided using a global enum message along with a statement that describes what condition you want.
For example if you wanted a kick engine to only run if the robot is statically stable or better.

```cpp
on<Provides<Kick>, When<Stability, std::greater_equal, Stability::STATIC>>().then(...);
```

These when conditions are updated by using normal NUClear emits.

### Causing

A causing statement is a promise that by running this provider, the desired state will be eventually reached.
This is used to allow smooth transitions beween modules.
For example when the walk engine stopped moving it would be in a "Standing" stability state.
This means the walk engine could have a `Leaving` reaction that caused this state so other modules know it can use this to be standing before they execute their actions.

```cpp
on<Provide<Walk>, Causing<Stability, Stability::STANDING>().then(...);
```

Other providers will take advantage of this in two ways.
If the other provider has higher priority than this one, it will force this provider group to switch to a `Provides` or `Leaving` that has a causing that satisfies the when condition it is limited on.
If the other provider has lower priority than this one, it will only be able to force this provider to change to another `Provides` statement and not a leavign one.

## Tasks

Tasks are the jobs that should be executed using the providers.
Tasks are implemented using NUClears `emit` along with a custom scope `emit<Task>`.

### Root level tasks

When a task is emitted from a reaction which is not a provider, that task is considered a root level task.
These root level tasks are all considered siblings within the priority comparision system at the root level of the graph.
When a root level task is emitted with 0 priority it is removed from the list of tasks.

### Subtasks

A subtask is a task that is emitted by a provider.
When multiple tasks are emitted by a provider, each of these are sibling tasks in the director graph.

### Priority

Priority in the Director is considered based on the closest common anscestor.
For root tasks this will be the root element.
Once the closest common anscestor is determined, the priority of the branch we are on is compared to the priority of the branch of the other task.
The winner gets to use the resources and potentially evict the other task to wait in the queue for the provider group.

Tasks can also be emitted as optional tasks, if when finding a common anscestor between two tasks, an optional task is found in the parantage of a task before the common anscestor that task is considered "optional".
If one task has an optional parentage and the other does not then the optional task will automatically lose.
If both have optional tasks in their perantage, then the tasks will be compared using their common anscestor as normal as if the optional was not there.
This means the higher priority root tasks optional elements are more important than a lower priority tasks optional elements.

### Done tasks

A Done task is a special task that can be emitted by a provider to signal to its parent that it has completed the task that was assigned to it.
The provider group that created this task will then be re-executed with the knowledge that it was triggered as a done event from below.
If a root task emits a `Done` task then it will be removed from the Director's root tasks as if it were emitted with a priority of 0.

## The Director Graph

TODO algorithm development in progress

## Behaviours Layout

In the NUbots codebase there are several different levels of behaviours that are used to group what each task will do.
To the Director they are all equivalent but to make it easier for developers they are split into several different layers.

### Behaviour

Behavour modules are the highest level modules and during normal debugging these will be the primary tasks that will be executed by the system.
They live in `modules/behaviour/behaviour` in the source code.
The generally will describe the overall goals and behavour of the robot.
Some examples of a behavour level module would be:

- Striker: Combines stratigies to walk to the ball and kick it to the opposing goal
- Defender: Combines strategies needed to intercept and defend incoming goals
- Goalie: Combines strategies needed to stay near the goal and prevents the opponents to score

### Strategy

Behaviours are modules that make high level strategy decisions for the robot.
They live in `modules/behaviour/strategy` in the source code.
These modules are the behaviour elements that provide the "what" components rather than the "how" components.
They will generally combine information from multiple systems in order to
Some examples of strategy level modules would be:

- WalkToBall: Tells the walk path planner to walk to the ball location
- LookForBall: Tells the look planner to look for a specific set of objects

### Planners

Planners are where the system starts to think about the "how" part of behavour.
They live in `modules/behaviour/planner` in the source code.
Planner modules are modules which string together a set of skills in order to achive their goal.
They are only interested in a single component of perofrming an action, such as walking a path or

- WalkPathPlanner: Strings together walk commands
- LookPlanner: Controls how the robot is looking for a specific object or set of objects

### Skills

- Walk: The walk engine which walks given a walk command
- Kick: Kicks the ball according to the desired direction
- Look: Gets the head to look at a paticular location

### Motions

The motions layer is concenred with implmementing the primitive actions

- ScriptRunner: Executes scripts given to it
- InverseKinematics: Takes limb positions/head positions and converts them into servo positions

### Platform

The platform layer deals with sending commands to the hardware itself.
These modules should not have subtasks and will form the leaf nodes in the directors graph.
Examples are modules such as:

- Webots
- HardwareIO
